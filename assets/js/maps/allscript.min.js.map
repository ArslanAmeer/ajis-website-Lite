{"version":3,"sources":["script.js","lib/smoothscroll.js"],"names":["nav","document","getElementById","logo_img","logo","style","scrollFunction","body","scrollTop","documentElement","classList","add","height","remove","transition","window","onscroll","onclick","scroll","top","left","behavior","w","d","isMicrosoftBrowser","userAgent","RegExp","join","test","polyfill","__forceSmoothScrollPolyfill__","Element","HTMLElement","SCROLL_TIME","ROUNDING_TOLERANCE","navigator","original","scrollTo","scrollBy","elementScroll","prototype","scrollElement","scrollIntoView","now","performance","bind","Date","undefined","arguments","shouldBailOut","smoothScroll","call","scrollX","pageXOffset","scrollY","pageYOffset","this","scrollLeft","SyntaxError","scrollableParent","el","isBody","parentNode","isScrollable","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","TypeError","hasScrollableSpace","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollableY","isScrollableX","step","context","value","currentX","currentY","k","elapsed","startTime","Math","cos","PI","startX","startY","method","scrollable","requestAnimationFrame","exports","module"],"mappings":"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","file":"../allscript.min.js","sourcesContent":["var nav = document.getElementById(\"top-nav\");\r\nvar logo_img = document.getElementById(\"logo-img\");\r\n\r\nvar logo = logo_img.style;\r\nwindow.onscroll = function () { scrollFunction() };\r\n\r\nfunction scrollFunction() {\r\n    \r\n    if (document.body.scrollTop > 50 || document.documentElement.scrollTop > 50) {\r\n        nav.classList.add(\"show-color\");\r\n        logo_img.style.height = \"60px\";\r\n    }\r\n\r\n    else {\r\n        nav.classList.remove(\"show-color\");\r\n        nav.style.transition = \".5s\";\r\n        logo.height = \"100px\";\r\n        logo.transition = \".5s\";\r\n    }\r\n\r\n}\r\n\r\n\r\n// Scrolling To Section\r\n\r\ndocument.getElementById(\"logo\").onclick = function () {\r\n    window.scroll({ top:0, left:0, behavior: \"smooth\" });\r\n}\r\n\r\ndocument.getElementById(\"about-us\").onclick = function () {\r\n    window.scroll({ top:740, left:0, behavior: \"smooth\" });\r\n}","'use strict';\n\n/*\n * aliases\n * w: window global object\n * d: document\n */\nvar w = window;\nvar d = document;\n\n/**\n * indicates if a the current browser is made by Microsoft\n * @method isMicrosoftBrowser\n * @param {String} userAgent\n * @returns {Boolean}\n */\nfunction isMicrosoftBrowser(userAgent) {\n  var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n  return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n}\n\n // polyfill\nfunction polyfill() {\n  // return if scroll behavior is supported and polyfill is not forced\n  if ('scrollBehavior' in d.documentElement.style\n    && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n\n  // globals\n  var Element = w.HTMLElement || w.Element;\n  var SCROLL_TIME = 468;\n\n  /*\n   * IE has rounding bug rounding down clientHeight and clientWidth and\n   * rounding up scrollHeight and scrollWidth causing false positives\n   * on hasScrollableSpace\n   */\n  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n  // object gathering original scroll methods\n  var original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element.prototype.scroll || scrollElement,\n    scrollIntoView: Element.prototype.scrollIntoView\n  };\n\n  // define timing method\n  var now = w.performance && w.performance.now\n    ? w.performance.now.bind(w.performance)\n    : Date.now;\n\n  /**\n   * changes scroll position inside an element\n   * @method scrollElement\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n\n  /**\n   * returns result of applying ease math function to a number\n   * @method ease\n   * @param {Number} k\n   * @returns {Number}\n   */\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  /**\n   * indicates if a smooth behavior should be applied\n   * @method shouldBailOut\n   * @param {Number|Object} firstArg\n   * @returns {Boolean}\n   */\n  function shouldBailOut(firstArg) {\n    if (firstArg === null\n      || typeof firstArg !== 'object'\n      || firstArg.behavior === undefined\n      || firstArg.behavior === 'auto'\n      || firstArg.behavior === 'instant') {\n      // first argument is not an object/null\n      // or behavior is auto, instant or undefined\n      return true;\n    }\n\n    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n      // first argument is an object and behavior is smooth\n      return false;\n    }\n\n    // throw error when behavior is not supported\n    throw new TypeError(\n      'behavior member of ScrollOptions '\n      + firstArg.behavior\n      + ' is not a valid value for enumeration ScrollBehavior.'\n    );\n  }\n\n  /**\n   * indicates if an element has scrollable space in the provided axis\n   * @method hasScrollableSpace\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function hasScrollableSpace(el, axis) {\n    if (axis === 'Y') {\n      return (el.clientHeight + ROUNDING_TOLERANCE) < el.scrollHeight;\n    }\n\n    if (axis === 'X') {\n      return (el.clientWidth + ROUNDING_TOLERANCE) < el.scrollWidth;\n    }\n  }\n\n  /**\n   * indicates if an element has a scrollable overflow property in the axis\n   * @method canOverflow\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function canOverflow(el, axis) {\n    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n    return overflowValue === 'auto' || overflowValue === 'scroll';\n  }\n\n  /**\n   * indicates if an element can be scrolled in either axis\n   * @method isScrollable\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function isScrollable(el) {\n    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n    return isScrollableY || isScrollableX;\n  }\n\n  /**\n   * finds scrollable parent of an element\n   * @method findScrollableParent\n   * @param {Node} el\n   * @returns {Node} el\n   */\n  function findScrollableParent(el) {\n    var isBody;\n\n    do {\n      el = el.parentNode;\n\n      isBody = el === d.body;\n    } while (isBody === false && isScrollable(el) === false);\n\n    isBody = null;\n\n    return el;\n  }\n\n  /**\n   * self invoked function that, given a context, steps through scrolling\n   * @method step\n   * @param {Object} context\n   * @returns {undefined}\n   */\n  function step(context) {\n    var time = now();\n    var value;\n    var currentX;\n    var currentY;\n    var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n    // avoid elapsed times higher than one\n    elapsed = elapsed > 1 ? 1 : elapsed;\n\n    // apply easing to elapsed time\n    value = ease(elapsed);\n\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n\n    context.method.call(context.scrollable, currentX, currentY);\n\n    // scroll more if we have not reached our destination\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n\n  /**\n   * scrolls window or element with a smooth behavior\n   * @method smoothScroll\n   * @param {Object|Node} el\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function smoothScroll(el, x, y) {\n    var scrollable;\n    var startX;\n    var startY;\n    var method;\n    var startTime = now();\n\n    // define scroll context\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n\n    // scroll looping over a frame\n    step({\n      scrollable: scrollable,\n      method: method,\n      startTime: startTime,\n      startX: startX,\n      startY: startY,\n      x: x,\n      y: y\n    });\n  }\n\n  // ORIGINAL METHODS OVERRIDES\n  // w.scroll and w.scrollTo\n  w.scroll = w.scrollTo = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? arguments[0]\n            : (w.scrollX || w.pageXOffset),\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n            ? arguments[1]\n            : (w.scrollY || w.pageYOffset)\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== undefined\n        ? ~~arguments[0].left\n        : (w.scrollX || w.pageXOffset),\n      arguments[0].top !== undefined\n        ? ~~arguments[0].top\n        : (w.scrollY || w.pageYOffset)\n    );\n  };\n\n  // w.scrollBy\n  w.scrollBy = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? arguments[0]\n            : 0,\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n           ? arguments[1]\n           : 0\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n    );\n  };\n\n  // Element.prototype.scroll and Element.prototype.scrollTo\n  Element.prototype.scroll = Element.prototype.scrollTo = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      // if one number is passed, throw error to match Firefox implementation\n      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n        throw new SyntaxError('Value couldn\\'t be converted');\n      }\n\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? ~~arguments[0]\n            : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : arguments[1] !== undefined\n            ? ~~arguments[1]\n            : this.scrollTop\n      );\n\n      return;\n    }\n\n    var left = arguments[0].left;\n    var top = arguments[0].top;\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === 'undefined' ? this.scrollLeft : ~~left,\n      typeof top === 'undefined' ? this.scrollTop : ~~top\n    );\n  };\n\n  // Element.prototype.scrollBy\n  Element.prototype.scrollBy = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left + this.scrollLeft\n          : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top + this.scrollTop\n          : ~~arguments[1] + this.scrollTop\n      );\n\n      return;\n    }\n\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n\n  // Element.prototype.scrollIntoView\n  Element.prototype.scrollIntoView = function() {\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === undefined\n          ? true\n          : arguments[0]\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    var scrollableParent = findScrollableParent(this);\n    var parentRects = scrollableParent.getBoundingClientRect();\n    var clientRects = this.getBoundingClientRect();\n\n    if (scrollableParent !== d.body) {\n      // reveal element inside parent\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top\n      );\n\n      // reveal parent in viewport unless is fixed\n      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      }\n    } else {\n      // reveal element in viewport\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: 'smooth'\n      });\n    }\n  };\n}\n\nif (typeof exports === 'object') {\n  // commonjs\n  module.exports = { polyfill: polyfill };\n} else {\n  // global\n  polyfill();\n}\n"]}