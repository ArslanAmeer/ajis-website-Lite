{"version":3,"sources":["script.js","lib/smoothscroll.js"],"names":["nav","document","getElementById","logo_img","logo","style","scrollFunction","body","scrollTop","documentElement","classList","add","height","remove","transition","window","onscroll","w","d","isMicrosoftBrowser","userAgent","RegExp","join","test","polyfill","__forceSmoothScrollPolyfill__","Element","HTMLElement","SCROLL_TIME","ROUNDING_TOLERANCE","navigator","original","scroll","scrollTo","scrollBy","elementScroll","prototype","scrollElement","scrollIntoView","now","performance","bind","Date","undefined","arguments","shouldBailOut","smoothScroll","call","left","scrollX","pageXOffset","top","scrollY","pageYOffset","this","scrollLeft","SyntaxError","behavior","scrollableParent","el","isBody","parentNode","isScrollable","findScrollableParent","parentRects","getBoundingClientRect","clientRects","getComputedStyle","position","x","y","firstArg","TypeError","hasScrollableSpace","axis","clientHeight","scrollHeight","clientWidth","scrollWidth","canOverflow","overflowValue","isScrollableY","isScrollableX","step","context","value","currentX","currentY","k","elapsed","startTime","Math","cos","PI","startX","startY","method","scrollable","requestAnimationFrame","exports","module"],"mappings":"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","file":"../allscript.min.js","sourcesContent":["var nav = document.getElementById(\"top-nav\");\r\nvar logo_img = document.getElementById(\"logo-img\");\r\n\r\nvar logo = logo_img.style;\r\nwindow.onscroll = function () { scrollFunction() };\r\n\r\nfunction scrollFunction() {\r\n    \r\n    if (document.body.scrollTop > 50 || document.documentElement.scrollTop > 50) {\r\n        nav.classList.add(\"show-color\");\r\n        logo_img.style.height = \"60px\";\r\n    }\r\n\r\n    else {\r\n        nav.classList.remove(\"show-color\");\r\n        nav.style.transition = \".5s\";\r\n        logo.height = \"100px\";\r\n        logo.transition = \".5s\";\r\n    }\r\n\r\n}\r\n","'use strict';\n\n/*\n * aliases\n * w: window global object\n * d: document\n */\nvar w = window;\nvar d = document;\n\n/**\n * indicates if a the current browser is made by Microsoft\n * @method isMicrosoftBrowser\n * @param {String} userAgent\n * @returns {Boolean}\n */\nfunction isMicrosoftBrowser(userAgent) {\n  var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n\n  return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n}\n\n // polyfill\nfunction polyfill() {\n  // return if scroll behavior is supported and polyfill is not forced\n  if ('scrollBehavior' in d.documentElement.style\n    && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n\n  // globals\n  var Element = w.HTMLElement || w.Element;\n  var SCROLL_TIME = 468;\n\n  /*\n   * IE has rounding bug rounding down clientHeight and clientWidth and\n   * rounding up scrollHeight and scrollWidth causing false positives\n   * on hasScrollableSpace\n   */\n  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n  // object gathering original scroll methods\n  var original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element.prototype.scroll || scrollElement,\n    scrollIntoView: Element.prototype.scrollIntoView\n  };\n\n  // define timing method\n  var now = w.performance && w.performance.now\n    ? w.performance.now.bind(w.performance)\n    : Date.now;\n\n  /**\n   * changes scroll position inside an element\n   * @method scrollElement\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n\n  /**\n   * returns result of applying ease math function to a number\n   * @method ease\n   * @param {Number} k\n   * @returns {Number}\n   */\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  /**\n   * indicates if a smooth behavior should be applied\n   * @method shouldBailOut\n   * @param {Number|Object} firstArg\n   * @returns {Boolean}\n   */\n  function shouldBailOut(firstArg) {\n    if (firstArg === null\n      || typeof firstArg !== 'object'\n      || firstArg.behavior === undefined\n      || firstArg.behavior === 'auto'\n      || firstArg.behavior === 'instant') {\n      // first argument is not an object/null\n      // or behavior is auto, instant or undefined\n      return true;\n    }\n\n    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n      // first argument is an object and behavior is smooth\n      return false;\n    }\n\n    // throw error when behavior is not supported\n    throw new TypeError(\n      'behavior member of ScrollOptions '\n      + firstArg.behavior\n      + ' is not a valid value for enumeration ScrollBehavior.'\n    );\n  }\n\n  /**\n   * indicates if an element has scrollable space in the provided axis\n   * @method hasScrollableSpace\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function hasScrollableSpace(el, axis) {\n    if (axis === 'Y') {\n      return (el.clientHeight + ROUNDING_TOLERANCE) < el.scrollHeight;\n    }\n\n    if (axis === 'X') {\n      return (el.clientWidth + ROUNDING_TOLERANCE) < el.scrollWidth;\n    }\n  }\n\n  /**\n   * indicates if an element has a scrollable overflow property in the axis\n   * @method canOverflow\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function canOverflow(el, axis) {\n    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n\n    return overflowValue === 'auto' || overflowValue === 'scroll';\n  }\n\n  /**\n   * indicates if an element can be scrolled in either axis\n   * @method isScrollable\n   * @param {Node} el\n   * @param {String} axis\n   * @returns {Boolean}\n   */\n  function isScrollable(el) {\n    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n\n    return isScrollableY || isScrollableX;\n  }\n\n  /**\n   * finds scrollable parent of an element\n   * @method findScrollableParent\n   * @param {Node} el\n   * @returns {Node} el\n   */\n  function findScrollableParent(el) {\n    var isBody;\n\n    do {\n      el = el.parentNode;\n\n      isBody = el === d.body;\n    } while (isBody === false && isScrollable(el) === false);\n\n    isBody = null;\n\n    return el;\n  }\n\n  /**\n   * self invoked function that, given a context, steps through scrolling\n   * @method step\n   * @param {Object} context\n   * @returns {undefined}\n   */\n  function step(context) {\n    var time = now();\n    var value;\n    var currentX;\n    var currentY;\n    var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n    // avoid elapsed times higher than one\n    elapsed = elapsed > 1 ? 1 : elapsed;\n\n    // apply easing to elapsed time\n    value = ease(elapsed);\n\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n\n    context.method.call(context.scrollable, currentX, currentY);\n\n    // scroll more if we have not reached our destination\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n\n  /**\n   * scrolls window or element with a smooth behavior\n   * @method smoothScroll\n   * @param {Object|Node} el\n   * @param {Number} x\n   * @param {Number} y\n   * @returns {undefined}\n   */\n  function smoothScroll(el, x, y) {\n    var scrollable;\n    var startX;\n    var startY;\n    var method;\n    var startTime = now();\n\n    // define scroll context\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n\n    // scroll looping over a frame\n    step({\n      scrollable: scrollable,\n      method: method,\n      startTime: startTime,\n      startX: startX,\n      startY: startY,\n      x: x,\n      y: y\n    });\n  }\n\n  // ORIGINAL METHODS OVERRIDES\n  // w.scroll and w.scrollTo\n  w.scroll = w.scrollTo = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? arguments[0]\n            : (w.scrollX || w.pageXOffset),\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n            ? arguments[1]\n            : (w.scrollY || w.pageYOffset)\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== undefined\n        ? ~~arguments[0].left\n        : (w.scrollX || w.pageXOffset),\n      arguments[0].top !== undefined\n        ? ~~arguments[0].top\n        : (w.scrollY || w.pageYOffset)\n    );\n  };\n\n  // w.scrollBy\n  w.scrollBy = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== undefined\n          ? arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? arguments[0]\n            : 0,\n        arguments[0].top !== undefined\n          ? arguments[0].top\n          : arguments[1] !== undefined\n           ? arguments[1]\n           : 0\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n    );\n  };\n\n  // Element.prototype.scroll and Element.prototype.scrollTo\n  Element.prototype.scroll = Element.prototype.scrollTo = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      // if one number is passed, throw error to match Firefox implementation\n      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n        throw new SyntaxError('Value couldn\\'t be converted');\n      }\n\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left\n          : typeof arguments[0] !== 'object'\n            ? ~~arguments[0]\n            : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top\n          : arguments[1] !== undefined\n            ? ~~arguments[1]\n            : this.scrollTop\n      );\n\n      return;\n    }\n\n    var left = arguments[0].left;\n    var top = arguments[0].top;\n\n    // LET THE SMOOTHNESS BEGIN!\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === 'undefined' ? this.scrollLeft : ~~left,\n      typeof top === 'undefined' ? this.scrollTop : ~~top\n    );\n  };\n\n  // Element.prototype.scrollBy\n  Element.prototype.scrollBy = function() {\n    // avoid action when no arguments are passed\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== undefined\n          ? ~~arguments[0].left + this.scrollLeft\n          : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== undefined\n          ? ~~arguments[0].top + this.scrollTop\n          : ~~arguments[1] + this.scrollTop\n      );\n\n      return;\n    }\n\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n\n  // Element.prototype.scrollIntoView\n  Element.prototype.scrollIntoView = function() {\n    // avoid smooth behavior if not required\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === undefined\n          ? true\n          : arguments[0]\n      );\n\n      return;\n    }\n\n    // LET THE SMOOTHNESS BEGIN!\n    var scrollableParent = findScrollableParent(this);\n    var parentRects = scrollableParent.getBoundingClientRect();\n    var clientRects = this.getBoundingClientRect();\n\n    if (scrollableParent !== d.body) {\n      // reveal element inside parent\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top\n      );\n\n      // reveal parent in viewport unless is fixed\n      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      }\n    } else {\n      // reveal element in viewport\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: 'smooth'\n      });\n    }\n  };\n}\n\nif (typeof exports === 'object') {\n  // commonjs\n  module.exports = { polyfill: polyfill };\n} else {\n  // global\n  polyfill();\n}\n"]}